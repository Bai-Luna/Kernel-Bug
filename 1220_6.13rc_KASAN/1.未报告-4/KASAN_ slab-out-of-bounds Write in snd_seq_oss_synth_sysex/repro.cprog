// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>

static void sleep_ms(uint64_t ms)
{
	usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts))
	exit(1);
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void thread_start(void* (*fn)(void*), void* arg)
{
	pthread_t th;
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setstacksize(&attr, 128 << 10);
	int i = 0;
	for (; i < 100; i++) {
		if (pthread_create(&th, &attr, fn, arg) == 0) {
			pthread_attr_destroy(&attr);
			return;
		}
		if (errno == EAGAIN) {
			usleep(50);
			continue;
		}
		break;
	}
	exit(1);
}

typedef struct {
	int state;
} event_t;

static void event_init(event_t* ev)
{
	ev->state = 0;
}

static void event_reset(event_t* ev)
{
	ev->state = 0;
}

static void event_set(event_t* ev)
{
	if (ev->state)
	exit(1);
	__atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
	syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1000000);
}

static void event_wait(event_t* ev)
{
	while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
		syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
	return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
	uint64_t start = current_time_ms();
	uint64_t now = start;
	for (;;) {
		uint64_t remain = timeout - (now - start);
		struct timespec ts;
		ts.tv_sec = remain / 1000;
		ts.tv_nsec = (remain % 1000) * 1000 * 1000;
		syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
		if (__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
			return 1;
		now = current_time_ms();
		if (now - start > timeout)
			return 0;
	}
}

static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}

static void kill_and_wait(int pid, int* status)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
	for (int i = 0; i < 100; i++) {
		if (waitpid(-1, status, WNOHANG | __WALL) == pid)
			return;
		usleep(1000);
	}
	DIR* dir = opendir("/sys/fs/fuse/connections");
	if (dir) {
		for (;;) {
			struct dirent* ent = readdir(dir);
			if (!ent)
				break;
			if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
				continue;
			char abort[300];
			snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort", ent->d_name);
			int fd = open(abort, O_WRONLY);
			if (fd == -1) {
				continue;
			}
			if (write(fd, abort, 1) < 0) {
			}
			close(fd);
		}
		closedir(dir);
	} else {
	}
	while (waitpid(-1, status, __WALL) != pid) {
	}
}

static void setup_test()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	setpgrp();
	write_file("/proc/self/oom_score_adj", "1000");
}

struct thread_t {
	int created, call;
	event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
	struct thread_t* th = (struct thread_t*)arg;
	for (;;) {
		event_wait(&th->ready);
		event_reset(&th->ready);
		execute_call(th->call);
		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
		event_set(&th->done);
	}
	return 0;
}

static void execute_one(void)
{
	if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
	}
	int i, call, thread;
	for (call = 0; call < 3; call++) {
		for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0])); thread++) {
			struct thread_t* th = &threads[thread];
			if (!th->created) {
				th->created = 1;
				event_init(&th->ready);
				event_init(&th->done);
				event_set(&th->done);
				thread_start(thr, th);
			}
			if (!event_isset(&th->done))
				continue;
			event_reset(&th->done);
			th->call = call;
			__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
			event_set(&th->ready);
			if (call == 1)
				break;
			event_timedwait(&th->done, 50);
			break;
		}
	}
	for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
		sleep_ms(1);
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
	int iter = 0;
	for (;; iter++) {
		int pid = fork();
		if (pid < 0)
	exit(1);
		if (pid == 0) {
			setup_test();
			execute_one();
			exit(0);
		}
		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			sleep_ms(10);
			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
				break;
			if (current_time_ms() - start < 5000)
				continue;
			kill_and_wait(pid, &status);
			break;
		}
	}
}

uint64_t r[1] = {0xffffffffffffffff};

void execute_call(int call)
{
		intptr_t res = 0;
	switch (call) {
	case 0:
memcpy((void*)0x20000500, "/dev/sequencer2\000", 16);
		res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul, /*file=*/0x20000500ul, /*flags=O_WRONLY*/1, /*mode=*/0);
		if (res != -1)
				r[0] = res;
		break;
	case 1:
memcpy((void*)0x20000540, "\x94\x04\x39\x54", 4);
		syscall(__NR_write, /*fd=*/r[0], /*buffer=*/0x20000540ul, /*count=*/0x1dul);
		for (int i = 0; i < 64; i++) {
		syscall(__NR_write, /*fd=*/r[0], /*buffer=*/0x20000540ul, /*count=*/0x1dul);
		}
		break;
	case 2:
memcpy((void*)0x20000140, "\x94\x04\xab\x3f\x86\xf5\xda\xd6\x5c\xf3\x89\xf7\xd6\xf3\xd7\x89\xad\x31\x2d\xf7\xe8\x36\x33\xf4\xa0\x5f\x37\x93\x6b\x28\xcf\xc9\x93\x7e\x46\x1f\xf1\xfc\xe0\x26\x7e\x6e\x92\xa7\xd9\x03\xcc\x2a\x4b\xae\x11\x4c\xe0\x18\x70\x7c\xa2\x05\x00\x6a\x12\x46\xfa\xaa\xde\xbb\xe3\xb1\xa1\x83\x9e\x7e\x3e\xe9\x16\x92\x95\xf2\x33\xaa\x2d\xba\xcf\x2b\x7b\xbd\xe1\x20\xac\xc5\xe4\x71\xa9\x1b\xf1\x70\x04\x23\x2a\x20\x64\x1f\xa8\xf6\x98\x4a\x74\x67\x88\xc2\x5e\x8a\x4e\x6e\xc2\xc2\xe7\x5c\x5f\x0c\x02\x00\x00\x00\x00\x00\x00\x00\xda\x92\xeb\x07\x4d\xe0\xce\x37\x50\xcb\x7c\x13\x8d\xf4\x70\x32\x69\xcb\x42\x76\x39\x69\xb0\x1d\x9a\x19\x6f\x44\x9d\x34\xfd\xdb\xc4\x4a\xe4\x29\x1e\x6c\xa0\x24\x13\x60\xfc\xa1\x57\x9d\xce\x30\xb8\x97\x22\x06\xcd\x30\x01\x6b\xaf\x96\x1d\xd8\x05\x95\xdf\x83\xb9\x68\x76\x86\x5d\x89\x5b\x25\x82\xef\x04\x9d\xf3\x9c\xb3\xb0\xe6\x66\x4a\x7b\xdf\x2b\x3f\x69\xc6\x04\xa9\x8b\xb9\xf7\x34\xde\x33\x47\x93\x67\x09\xa2\x7d\x8a\x34\xc5\x89\xbd\x72\x6e\xaf\xee\x7e\x13\x8f\x4a\x6c\xc6\x89\xf6\xff\x69\x6f\x79\xc0\xda\x26\x73\xf2\xa0\xb1\x31\x29\xea\xee\x1e\xb0\x8e\xae\xf1\x44\xcd\x15\xb6\x78\xa5\xde\xb5\x14\x1d\x23\x1d\xbb\x99\xfb\xbd\x35\x95\x8e\x5c\xf8\xb2", 290);
		syscall(__NR_write, /*fd=*/r[0], /*buffer=*/0x20000140ul, /*count=*/8ul);
		for (int i = 0; i < 64; i++) {
		syscall(__NR_write, /*fd=*/r[0], /*buffer=*/0x20000140ul, /*count=*/8ul);
		}
		break;
	}

}
int main(void)
{
		syscall(__NR_mmap, /*addr=*/0x1ffff000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x20000000ul, /*len=*/0x1000000ul, /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/7ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x21000000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
	const char* reason;
	(void)reason;
			loop();
	return 0;
}
